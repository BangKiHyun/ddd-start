# 도메인 모델과 BOUNDED CONTEXT

## 도메인 모델과 경계

도메인 모델을 만들 때 한 도메인은 다시 여러 하위 도메인으로 구분된다. 한 개의 모델로 여러 하위 도메인을 표현하려면 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

### 상품 예제

카탈로그에서의 상품, 재고 관리에서의 상품은 같지만 실제로 의미하는 것이 다르다.

- 카탈로그에서의 상품: 상품 이미지, 명, 가격, 옵션 목록, 상세 설명과 같은 **상품 정보**를 의미
- 재고 관리에서의 상품: **실존하는 개별 객체를 추적**하기 위한 목적을 의미
- 즉, 카탈로그에서 물리적으로 한 개의 상품이 재고 관리에서는 여러 개 존재할 수 있다.

</br >

### 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우

- 카탈로그 도메인에서 **상품**이 검색 도메인에서는 **문서**로 불리기도 한다.
- 시스템을 사용하는 사람을 **회원** 이라고 부르지만, 주문 도메인에서는 **주문자**, 배송 도메인에서는 **보내는 사람**이라 부르기도 한다.

**이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 도메인을 표현하려는 시도는 올바른 방법이 아니다.**

그러므로 하위 도메인마다 모델을 만드는게 좋다.

</br >

## BOUNDED CONTEXT

BOUNDED CONTEXT는 모델의 경계를 결정하며 **한 개의 BOUNDED CONTEXT는 논리적으로 한 개의 모델을 갖는다.**

**BOUNDED CONTEXT는 용어를 기준으로 구분한다.** 예로, 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리한다.

### 주의할 점

- 만약 하위 도메인을 하나의 BOUNDED CONTEXT에서 개발할 때 하위 도메인 모델이 뒤섞이지 않도록 해야 한다.
- 뒤섞이게 된다면 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해 하위 도메인별 기능 확장이 어렵게 된다.
- 한 개의 BOUNDED CONTEXT에서 여러 하위 도메인을 표현하더라도 하위 도메인마다 구분되는 패키지를 갖도록 하자.

</br >

### BOUNDED CONTEXT는 각자 구현하는 하위 도메인에 맞는 모델을 갖는다.

같은 사용자라 하더라도 회원의 Member는 애그리거트 루트이지만 주문의 Orderer는 밸류가 된다.

카탈로그의 Product는 상품이 속할 Category와 연관을 갖지만 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.

![image](https://user-images.githubusercontent.com/43977617/103507330-425d2080-4ea2-11eb-8ca8-65243e747fcc.png)

</br >

## BOUNDED CONTEXT의 구현

BOUNDED CONTEXT는 도메인 모델뿐만 아니라 도메인 기능을 사용자에게 제공하는데 필요한 **표현 영역, 응용 서비스, 인프라 영역 등 모두 포함한다.**

- 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 해당 **테이블도 BOUNDED CONTEXT에 포함**
- 표현 영역은 사용자를 위한 HTML 페이지를 생성할 수도 있고, 다른 BOUNDED CONTEXT를 위한 REST API를 제공할 수 있다.

### 각 BOUNDED CONTEXT간 서로 다른 기술 사용

각 BOUNDED CONTEXT는 서로 다른 구현 기술을 사용할 수도 있다.

- 웹 MVC는 스프링 MVC를 사용하고 리포지토리 구현 기술로 JPA/Hibernate를 사용하는 BOUNDED CONTEXT
- Netty를 이용해서 REST API를 제공하고 MyBatis를 리포지터리 구현 기술로 사용하는 BOUNDED CONTEXT

